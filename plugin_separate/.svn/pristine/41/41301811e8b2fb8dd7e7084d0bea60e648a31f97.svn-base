package com.hajduczek.xmleditor;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSSerializer;

public class XMLParser {
	
	
	public static XmlDocument parse(String xml, String[] schemaDirs) throws Exception {
		//String xml = "<xml><tag><inner attr=\"val\">tekst</inner><inner2 imie=\"Jan\" nazwisko=\"Kowalski\"/></tag><tag2 name=\"Lisa\">Maria</tag2></xml>";
		//generateDOTGraph(xml);
		long startTime = System.currentTimeMillis();
		Document doc = null;
		{
			DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = fact.newDocumentBuilder();
			//ustawienie zewnetrznego folderu z ktorego ma byc pobierane DTD
			//TODO: w preferencjach projektu ma byc istawiane workingDirectoryURI!!!
			
			
			builder.setEntityResolver(new MyEntityResolver(schemaDirs));
			
			/*	new EntityResolver() {
					public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
				         if (systemId != null && systemId.startsWith("file:/")) {
					         URI workingDirectoryURI = new File("C:\\Users\\hajdi\\workspace_czysty\\plugin_separate\\dtd").toURI();
					         URI workingFile;
				
				             try {
				            	 URI currentJavaWorkingDirectory = new File(System.getProperty("user.dir")).toURI();
				                 // Construction new File(new URI(String)).toURI() is used to be sure URI has correct representation without redundant '/'
				            	 workingFile = convertToNewWorkingDirectory(currentJavaWorkingDirectory, workingDirectoryURI, new File(new URI(systemId)).toURI());
				            	 return new InputSource(workingFile.toString());
				             } catch (URISyntaxException ex) {
				            	 ex.printStackTrace();
				             }
				         }
				         return null;
					}
				});*/
			
			InputStream is = new ByteArrayInputStream(xml.getBytes("UTF-8"));
			
			doc = builder.parse(is);
			is.close();
		}
		Map<Integer, List<String>> references = new HashMap<Integer, List<String>>();
		
		XmlDocument xmlDocument = new XmlDocument();
		
		XmlTag tag = DFS(doc, doc.getDocumentElement(), xmlDocument, references, 0);
		System.out.println("Referencje: " + references);
		xmlDocument.setChilds(tag.getChilds());
		//xmlDocument.setAttributes(tag.getAttributes());
		xmlDocument.setRootElement(tag);
		xmlDocument.setEncoding(doc.getXmlEncoding());
		xmlDocument.setVersion(doc.getXmlVersion());
		
		System.out.println(xmlDocument);
		System.out.println(xmlDocument.toDOTString());
		
		String svg = GraphVizCaller.callGraphViz(xmlDocument.toDOTString());
		
		SVGUtil.parseSVG(svg, xmlDocument);
		System.out.println(xmlDocument);
		
		//find edges START
		Map<Integer, Integer> edges = new HashMap<Integer, Integer>();
		
		for (Entry<Integer, List<String>> entry : references.entrySet()) {
			Integer tagId = entry.getKey();
			for (String attrId : entry.getValue()) {
				for (XmlTag xmlTag : xmlDocument.getChilds()) {
					String xmlTagId = null;
					for (Attribute attribute : xmlTag.getAttributes())  {
						if (attribute.getName().equalsIgnoreCase("id")) {
							xmlTagId = attribute.getValue();
							break;
						}
					}
					if (attrId.equals(xmlTagId)) {
						edges.put(tagId, xmlTag.getId());
					}
				}
			}
		}
		System.out.println("edges: " + edges);
		xmlDocument.setEdges(edges);
		
		//find edges END
		
		System.out.println("XMLParser.parse duration: " + ((System.currentTimeMillis()-startTime)/1000) + "s");
		return xmlDocument;
	}
	
	
	public static XmlTag DFS(Document document, Node node, XmlDocument xmlDocument, Map<Integer, List<String>> references, int positionInParent) {
		Element element = (Element) node;
		XmlTag tag = new XmlTag(positionInParent, node.getNodeName());
		xmlDocument.getChildsMap().put(tag.getId(), tag);
		//workaround by svgparser się nie wysypał
		xmlDocument.getChildsMap().put(tag.getChilds().get(0).getId(), tag.getChilds().get(0));
		
		for(int i=0; i<node.getChildNodes().getLength(); ++i){
			int nodeType = node.getChildNodes().item(i).getNodeType();
			if (nodeType == Node.ELEMENT_NODE) {
				tag.getChilds().add(DFS(document, node.getChildNodes().item(i), xmlDocument, references, i));
			} else if (nodeType == Node.TEXT_NODE) {
				String textContent = node.getChildNodes().item(i).getTextContent();
				if (textContent == null ){
					continue;
				}
				String trimmedTextContent = textContent.trim();
				if (textContent.length() > 0 && trimmedTextContent.length() > 0) {
					String firstCharOrg = textContent.substring(0, 1);
					String firstCharTrim = trimmedTextContent.substring(0, 1);
					if (firstCharOrg.equals(firstCharTrim)) {
						TextNode textNode = new TextNode(i, trimmedTextContent);
						tag.addTextElement(textNode);
					}
				}
			} 
		}
		
		buildComponent(tag, element, references);
		return tag;
	}
	
	public static void buildComponent(XmlTag tag, Element element, Map<Integer, List<String>> references) {
		 NamedNodeMap namedNodeMap = element.getAttributes();
		 Integer idAttr = null;
		 for (int i=0; i<namedNodeMap.getLength(); ++i) {
			 tag.getAttributes().add(new Attribute(namedNodeMap.item(i).getNodeName(), namedNodeMap.item(i).getNodeValue()));
			 //Wyszukiwanie referencji
			 //TODO: w przypadku referencji ref="id1,id2" split na podstawie , dorobic!
			 if ("id".equals(namedNodeMap.item(i).getNodeName())) {
				 idAttr = tag.getId();//namedNodeMap.item(i).getNodeValue();
			 }
			 if ("ref".equals(namedNodeMap.item(i).getNodeName())) {
				if (references.containsKey(idAttr)) {
					List<String> targets = references.get(idAttr);
					targets.add(namedNodeMap.item(i).getNodeValue());
				} else {
					List<String> targets = new ArrayList<String>();
					targets.add(namedNodeMap.item(i).getNodeValue());
					references.put(idAttr, targets);
				}
			 }
		 }
	}	
	
	public static String prettyPrintWithDOM3LS(String xml) {
		try {
			DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = fact.newDocumentBuilder();
			InputStream is = new ByteArrayInputStream(xml.getBytes("UTF-8"));
			Document document = builder.parse(is);
			DOMImplementation domImplementation = document.getImplementation();
			if (domImplementation.hasFeature("LS", "3.0") && domImplementation.hasFeature("Core", "2.0")) {
				DOMImplementationLS domImplementationLS = (DOMImplementationLS) domImplementation.getFeature("LS", "3.0");
				LSSerializer lsSerializer = domImplementationLS.createLSSerializer();
				DOMConfiguration domConfiguration = lsSerializer.getDomConfig();
				if (domConfiguration.canSetParameter("format-pretty-print", Boolean.TRUE)) {
					lsSerializer.getDomConfig().setParameter("format-pretty-print", Boolean.TRUE);
					LSOutput lsOutput = domImplementationLS.createLSOutput();
					lsOutput.setEncoding("UTF-8");
					StringWriter stringWriter = new StringWriter();
					lsOutput.setCharacterStream(stringWriter);
					lsSerializer.write(document, lsOutput);
					return stringWriter.toString();
				} else {
					throw new RuntimeException("DOMConfiguration 'format-pretty-print' parameter isn't settable.");
				}
			} else {
				throw new RuntimeException("DOM 3.0 LS and/or DOM 2.0 Core not supported.");
			}
		} catch (Exception e) {
			return xml;
		}
	}
}