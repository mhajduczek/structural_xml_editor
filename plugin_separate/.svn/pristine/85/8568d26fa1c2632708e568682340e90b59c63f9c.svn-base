package plugin_hello_world.editors;

import java.awt.Frame;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.jface.util.PropertyChangeEvent;
import org.eclipse.swt.SWT;
import org.eclipse.swt.awt.SWT_AWT;
import org.eclipse.swt.custom.StyledText;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.FontDialog;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.editors.text.TextEditor;
import org.eclipse.ui.ide.IDE;
import org.eclipse.ui.part.FileEditorInput;
import org.eclipse.ui.part.MultiPageEditorPart;

import plugin_hello_world.GraphData;
import plugin_hello_world.ListenerStore;
import plugin_hello_world.PropertiesPanel;
import plugin_hello_world.XMLParser;
import plugin_hello_world.XmlDocument;
import plugin_hello_world.XmlTag;

import com.mxgraph.model.mxCell;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.swing.mxGraphOutline;
import com.mxgraph.view.mxGraph;

/**
 * An example showing how to create a multi-page editor. This example has 3
 * pages:
 * <ul>
 * <li>page 0 contains a nested text editor.
 * <li>page 1 allows you to change the font used in page 2
 * <li>page 2 shows the words in page 0 in sorted order
 * </ul>
 */
public class MultiPageEditor extends MultiPageEditorPart implements
		IResourceChangeListener, IAdaptable {

	/** The text editor used in page 0. */
	private TextEditor editor;

	/** The font chosen in page 1. */
	private Font font;

	/** The text widget used in page 2. */
	private StyledText text;

	private boolean flag = true;

	Composite page1composite;
	Composite page2composite;

	mxGraphComponent graphComponent;
	PropertiesPanel propertiesPanel;
	XmlDocument xmlDocument;

	Frame frame = null;

	boolean valid = false;

	mxGraphOutline graphOutline = GraphData.getInstance().getGraphOutline();

	public Object getAdapter(Class required) {

		return super.getAdapter(required);
	}

	/**
	 * Creates a multi-page editor example.
	 */
	public MultiPageEditor() {
		super();
		ResourcesPlugin.getWorkspace().addResourceChangeListener(this);
	}

	/**
	 * Creates page 0 of the multi-page editor, which contains a text editor.
	 */
	void createPage0() {
		try {
			editor = new TextEditor();
			int index = addPage(editor, getEditorInput());
			setPageText(index, "XML");
		} catch (PartInitException e) {
			ErrorDialog.openError(getSite().getShell(),
					"Error creating nested text editor", null, e.getStatus());
		}
	}

	/**
	 * Creates page 1 of the multi-page editor, which allows you to change the
	 * font used in page 2.
	 */
	void createPage1() {
		page1composite = new Composite(getContainer(), SWT.NONE);
		reloadPage1(null);
		int index = addPage(page1composite);
		setPageText(index, "Schema");
	}

	private void reloadPage1(Image image) {
		Control[] childs = page1composite.getChildren();
		if (childs != null) {
			for (Control ctrl : childs) {
				ctrl.dispose();
			}
		}
		GridLayout layout = new GridLayout();
		page1composite.setLayout(layout);
		layout.numColumns = 2;

		Label label = new Label(page1composite, SWT.NONE);

		if (image == null) {
			image = new Image(getContainer().getDisplay(),
					"C:\\images\\dest.jpg");
		}
		label.setImage(image);

		page1composite.layout();
	}

	/**
	 * Creates page 2 of the multi-page editor, which shows the sorted text.
	 */
	void createPage2() {
		page2composite = new Composite(getContainer(), SWT.EMBEDDED
				| SWT.NO_BACKGROUND);
		int index = addPage(page2composite);
		frame = SWT_AWT.new_Frame(page2composite);
		loadPage2();
		setPageText(index, "Graph");
	}

	void createXmlDocument() {
		String xml = editor.getDocumentProvider()
				.getDocument(editor.getEditorInput()).get();
		// String xml =
		// "<xml><tag><inner attr=\"val\">tekst</inner><inner2 imie=\"Jan\" nazwisko=\"Kowalski\"/></tag><tag2 name=\"Lisa\">Maria</tag2></xml>";

		try {
			if (xml != null) {
				xmlDocument = XMLParser.parse(xml);
				valid = true;
			}
		} catch (Exception e) {
			valid = false;
			e.printStackTrace();
		}
	}

	void loadPage2() {
		long startTime = System.currentTimeMillis();

		createXmlDocument();

		frame.setLayout(new java.awt.GridLayout());
		mxGraph graph = new mxGraph();

		graphComponent = new mxGraphComponent(graph);

		drawNewGraph(graph);

		//graphOutline = new mxGraphOutline(graphComponent);
		graphOutline.setGraphComponent(graphComponent);
		//GraphData.getInstance().setGraphOutline(graphOutline);

		//propertiesPanel = new PropertiesPanel(null);

		graphComponent.setAutoscrolls(true);
		graphComponent.setAutoScroll(true);

		/* ustawianie listenera dla podgladu komponentu */
		graphComponent.getGraphControl().addMouseListener(new MouseAdapter() {
			
			public void mousePressed(MouseEvent e) {
				final mxCell cell = (mxCell) graphComponent.getCellAt(e.getX(),
						e.getY());
				if (cell == null) {
					System.out
							.println("teraz beda wyswietlane informacje o calym xmlu");
					ListenerStore.notify(new PropertyChangeEvent(this, "KrawedzKlik", "old", xmlDocument));
				} else if (cell.isEdge()) {
					System.out.println("Kliknalem w krawedz!");
					ListenerStore.notify(new PropertyChangeEvent(this, "KrawedzKlik", "old", null));
				} else if ((cell.getValue() instanceof XmlTag)) {
					System.out.println("Kliknalem w tag!");
					ListenerStore.notify(new PropertyChangeEvent(this, "KrawedzKlik", "old", (XmlTag)cell.getValue()));
					//propertiesPanel.setTag(cell.getValue());
				}
			}
		});

		frame.add(graphComponent);

		System.out.println("loadPage2 duration: "
				+ ((System.currentTimeMillis() - startTime) / 1000) + "s");
	}

	private void doSave() {
		clearGraph();
		drawNewGraph(this.graphComponent.getGraph());
	}

	private void clearGraph() {
		if (this.graphComponent != null) {
			mxGraph graph = this.graphComponent.getGraph();
			graph.removeCells(graph.getChildVertices(graph.getDefaultParent()));
		}
	}

	private void drawNewGraph(mxGraph graph) {
		createXmlDocument();
		if (valid) {
			Object parent = graph.getDefaultParent();
			graph.getModel().beginUpdate();
			try {
				//List<Object> vertexList = new ArrayList<Object>();
				List<XmlTag> tags = new ArrayList<XmlTag>(xmlDocument
						.getChildsMap().values());
				Collections.sort(tags, new Comparator<XmlTag>() {
					@Override
					public int compare(XmlTag arg0, XmlTag arg1) {
						if (arg0.getArea() < arg1.getArea()) {
							return -1;
						} else if (arg0.getArea() > arg1.getArea()) {
							return 1;
						} else {
							return 0;
						}
					}
				});
				boolean first = true;
				Map<Integer, Object> vertexMap = new HashMap<Integer, Object>();
				for (XmlTag tag : tags) {
					if (first) {
						first = false;
						continue;
					}
					//vertexList.add(graph.insertVertex(parent, null, tag, tag.getX(), tag.getY(), tag.getWidth(), tag.getHeight()))
					vertexMap.put(tag.getId(), graph.insertVertex(parent, null, tag,
							tag.getX(), tag.getY(), tag.getWidth(), tag.getHeight()));
				}
				for (Entry<Integer, Integer> entry : xmlDocument.getEdges().entrySet()) {
					graph.insertEdge(parent, null, null, vertexMap.get(entry.getKey()), vertexMap.get(entry.getValue()), "strokeColor=#66FF00");
				}
				// Object v1 = graph.insertVertex(parent, null, "Hello", 1500,
				// 1500, 100, 100);
				// Object v2 = graph.insertVertex(parent, null, "World!", -4,
				// 5, 599, 631);
				// graph.insertEdge(parent, null, "Edge", v1, v2);
				// graph.insertEdge(parent, null, "", vertexList.get(1),
				// vertexList.get(3));
			} finally {
				graph.getModel().endUpdate();
			}
		}
		graph.setCellsResizable(false);
		graph.setCellsEditable(false);
		graph.setCellsMovable(false);
		graph.setVertexLabelsMovable(false);
		graph.setAllowDanglingEdges(false);
		graph.setAutoOrigin(false);
	}

	/**
	 * Creates the pages of the multi-page editor.
	 */
	protected void createPages() {
		createPage0();
		createPage1();
		createPage2();
	}

	/**
	 * The <code>MultiPageEditorPart</code> implementation of this
	 * <code>IWorkbenchPart</code> method disposes all nested editors.
	 * Subclasses may extend.
	 */
	public void dispose() {
		ResourcesPlugin.getWorkspace().removeResourceChangeListener(this);
		super.dispose();
	}

	/**
	 * Saves the multi-page editor's document.
	 */
	public void doSave(IProgressMonitor monitor) {
		// TODO: w tym momencie bedzie generowany graf!!
		System.out.println("DO_SAVE");
		getEditor(0).doSave(monitor);
		doSave();
	}

	/**
	 * Saves the multi-page editor's document as another file. Also updates the
	 * text for page 0's tab, and updates this multi-page editor's input to
	 * correspond to the nested editor's.
	 */
	public void doSaveAs() {
		System.out.println("DO_SAVE_AS");
		IEditorPart editor = getEditor(0);
		editor.doSaveAs();
		setPageText(0, editor.getTitle());
		setInput(editor.getEditorInput());
	}

	/*
	 * (non-Javadoc) Method declared on IEditorPart
	 */
	public void gotoMarker(IMarker marker) {
		System.out.println("GO_TO_MARKER");
		setActivePage(0);
		IDE.gotoMarker(getEditor(0), marker);
	}

	/**
	 * The <code>MultiPageEditorExample</code> implementation of this method
	 * checks that the input is an instance of <code>IFileEditorInput</code>.
	 */
	public void init(IEditorSite site, IEditorInput editorInput)
			throws PartInitException {
		if (!(editorInput instanceof IFileEditorInput))
			throw new PartInitException(
					"Invalid Input: Must be IFileEditorInput");
		super.init(site, editorInput);
	}

	/*
	 * (non-Javadoc) Method declared on IEditorPart.
	 */
	public boolean isSaveAsAllowed() {
		return true;
	}

	/**
	 * Calculates the contents of page 2 when the it is activated.
	 */
	protected void pageChange(int newPageIndex) {
		super.pageChange(newPageIndex);
		switch (newPageIndex) {
		case 2:

			break;
		case 1:
			System.out.println("stronka1");
			try {
				doSth();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private void doSth() throws IOException {
		/*
		 * String xml = editor.getDocumentProvider()
		 * .getDocument(editor.getEditorInput()).get();
		 * 
		 * xml = xml.replaceAll("\\n", ""); xml = xml.replaceAll("> <", "><");
		 * xml = xml.replaceAll(">  <", "><"); xml = xml.replaceAll(">   <",
		 * "><"); xml = xml.replaceAll(">    <", "><"); xml =
		 * xml.replaceAll(">     <", "><"); xml = xml.replaceAll(">      <",
		 * "><"); xml = FirstRecipeDOM.generateDOTGraph(xml);
		 * 
		 * FileWriter outFile = new FileWriter(new File(
		 * "C:\\Program Files\\Graphviz 2.28\\bin\\", "g.gv")); PrintWriter out
		 * = new PrintWriter(outFile); out.println(xml); out.close();
		 * 
		 * String dotExecPath = "dot.exe -T png -o out.png g.gv";
		 * 
		 * Process process = Runtime.getRuntime().exec(dotExecPath, null, new
		 * File("C:\\Program Files\\Graphviz 2.28\\bin\\"));
		 * 
		 * try { process.waitFor(); } catch (InterruptedException e) {
		 * e.printStackTrace(); } // czeka na zakonczenie DOT'a
		 * 
		 * ImageLoader loader = new ImageLoader(); ImageData[] imageData =
		 * loader .load("C:\\Program Files\\Graphviz 2.28\\bin\\out.png"); Image
		 * image = new Image(Display.getDefault(), imageData[0]);
		 * 
		 * reloadPage1(image);
		 */
	}

	/**
	 * Closes all project files on project close.
	 */
	public void resourceChanged(final IResourceChangeEvent event) {
		if (event.getType() == IResourceChangeEvent.PRE_CLOSE) {
			Display.getDefault().asyncExec(new Runnable() {
				public void run() {
					IWorkbenchPage[] pages = getSite().getWorkbenchWindow()
							.getPages();
					for (int i = 0; i < pages.length; i++) {
						if (((FileEditorInput) editor.getEditorInput())
								.getFile().getProject()
								.equals(event.getResource())) {
							IEditorPart editorPart = pages[i].findEditor(editor
									.getEditorInput());
							pages[i].closeEditor(editorPart, true);
						}
					}
				}
			});
		}
	}

	/**
	 * Sets the font related data to be applied to the text in page 2.
	 */
	void setFont() {
		FontDialog fontDialog = new FontDialog(getSite().getShell());
		fontDialog.setFontList(text.getFont().getFontData());
		FontData fontData = fontDialog.open();
		if (fontData != null) {
			if (font != null)
				font.dispose();
			font = new Font(text.getDisplay(), fontData);
			text.setFont(font);
		}
	}

	/**
	 * Sorts the words in page 0, and shows them in page 2.
	 */
	void sortWords() {
	}
}
