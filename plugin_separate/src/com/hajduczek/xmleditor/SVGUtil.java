package com.hajduczek.xmleditor;

public class SVGUtil {
	public static void parseSVG(String svg, XmlDocument xmlDocument) throws Exception {
		//svg = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><!-- Generated by graphviz version 2.28.0 (20110507.0327) --><!-- Title: G Pages: 1 --><svg width=\"202pt\" height=\"164pt\" viewBox=\"0.00 0.00 202.00 164.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 160)\"><title>G</title><polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-160 199,-160 199,5 -4,5\"/><g id=\"graph2\" class=\"cluster\"><title>cluster_0123456789</title><polygon fill=\"none\" stroke=\"black\" points=\"0.144865,-0.296263 0.144865,-102.296 130.145,-102.296 130.145,-0.296263 0.144865,-0.296263\"/></g><g id=\"graph3\" class=\"cluster\"><title>cluster_3</title><polygon fill=\"none\" stroke=\"black\" points=\"68.2897,-58.5925 68.2897,-94.5925 122.29,-94.5925 122.29,-58.5925 68.2897,-58.5925\"/></g><g id=\"graph4\" class=\"cluster\"><title>cluster_4</title><polygon fill=\"none\" stroke=\"black\" points=\"8.28973,-8.59253 8.28973,-44.5925 62.2897,-44.5925 62.2897,-8.59253 8.28973,-8.59253\"/></g><g id=\"graph5\" class=\"cluster\"><title>cluster_5</title><polygon fill=\"none\" stroke=\"black\" points=\"140.145,-120.296 140.145,-156.296 194.145,-156.296 194.145,-120.296 140.145,-120.296\"/></g></g></svg>";
		char[] svgA = svg.toCharArray();
		int minX = 0;
		int minY = 0;
		int x1, y1, x2, y2, x3, y3, x4, y4;
		
		for (int i=8; i<svgA.length; ++i) {
			//cluster_
			StringBuilder s = new StringBuilder();
			s.append(svgA[i-8]);
			s.append(svgA[i-7]);
			s.append(svgA[i-6]);
			s.append(svgA[i-5]);
			s.append(svgA[i-4]);
			s.append(svgA[i-3]);
			s.append(svgA[i-2]);
			s.append(svgA[i-1]);
			//aktualnie metoda obsluguje do 8 poziomow zagniezdzenia elementow
			if (s.toString().equals("cluster_")) {
				s.append(svgA[i]);
				if((i+1) < svgA.length && !new Character('<').equals(svgA[i+1])) {
					s.append(svgA[i+1]);
					if((i+2) < svgA.length && !new Character('<').equals(svgA[i+2])) {
						s.append(svgA[i+2]);
						if((i+3) < svgA.length && !new Character('<').equals(svgA[i+3])) {
							s.append(svgA[i+3]);
							if((i+4) < svgA.length && !new Character('<').equals(svgA[i+4])) {
								s.append(svgA[i+4]);
								if((i+5) < svgA.length && !new Character('<').equals(svgA[i+5])) {
									s.append(svgA[i+5]);
									if((i+6) < svgA.length && !new Character('<').equals(svgA[i+6])) {
										s.append(svgA[i+6]);
										if((i+7) < svgA.length && !new Character('<').equals(svgA[i+7])) {
											s.append(svgA[i+7]);
											if((i+8) < svgA.length && !new Character('<').equals(svgA[i+8])) {
												s.append(svgA[i+8]);
												if((i+9) < svgA.length && !new Character('<').equals(svgA[i+9])) {
													s.append(svgA[i+9]);
													++i;
												}
												++i;
											}
											++i;
										}
										++i;
									}
									++i;
								}
								++i;
							}
							++i;
						}
						++i;
					}
					++i;
				}
				++i;
				//System.out.println(s); //tutaj mam cluster_xxxxx
				String objectId = s.toString().replace("cluster_", "");
				//TODO: find points 
				for (;i+6<svgA.length;++i) {
					StringBuilder s2 = new StringBuilder();
					s2.append(svgA[i]);
					s2.append(svgA[i+1]);
					s2.append(svgA[i+2]);
					s2.append(svgA[i+3]);
					s2.append(svgA[i+4]);
					s2.append(svgA[i+5]);
					s2.append(svgA[i+6]);
					
					if ("points=".equals(s2.toString())) {
						i += 8;
						//System.out.println("MAM POINTS");
						StringBuilder s3 = new StringBuilder();
						for (;i+1<svgA.length && svgA[i+1] != '\"' ;++i) {
							s3.append(svgA[i]);
						}
						//System.out.println(s3);
						String[] points = s3.toString().split(" ");
						
						x1 = (int)Double.parseDouble(points[0].split(",")[0]);
						y1 = (int)Double.parseDouble(points[0].split(",")[1]);
						x2 = (int)Double.parseDouble(points[1].split(",")[0]);
						y2 = (int)Double.parseDouble(points[1].split(",")[1]);
						x3 = (int)Double.parseDouble(points[2].split(",")[0]);
						y3 = (int)Double.parseDouble(points[2].split(",")[1]);
						x4 = (int)Double.parseDouble(points[3].split(",")[0]);
						y4 = (int)Double.parseDouble(points[3].split(",")[1]);
						
						xmlDocument.getChildsMap().get(Integer.parseInt(objectId)).vertexPosition(x1, y1, x2, y2, x3, y3, x4, y4);
						
						if (xmlDocument.getChildsMap().get(Integer.parseInt(objectId)).getX() < minX)
							minX = xmlDocument.getChildsMap().get(Integer.parseInt(objectId)).getX();
						if (xmlDocument.getChildsMap().get(Integer.parseInt(objectId)).getY() < minY)
							minY = xmlDocument.getChildsMap().get(Integer.parseInt(objectId)).getY();
			
						break;
					}
 				}
				//TODO: iteruj i sklejaj tak dlugo az napotkasz drugi "
				//TODO: nastepnie wydziel z tego punkty
				//TODO: wyszukaj w hashmap'ie obiekt i przypisz do niego punkty
			}
		}
		
		for (XmlTag tag : xmlDocument.getChildsMap().values()) {
			tag.addOffset(Math.abs(minX)+10, Math.abs(minY)+10);
		}
	}
}
